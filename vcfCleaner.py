#!/usr/bin/env python
import sys, os, webbrowser, tempfile, shutil, traceback
from collections import defaultdict
from PySide.QtCore import Qt, QFile
from PySide.QtUiTools import QUiLoader
from PySide.QtGui import QApplication, QFileDialog, QProgressDialog, QMessageBox, QComboBox, QTableWidgetItem, QTreeWidgetItem, QPushButton, QColor, QPalette, QBrush, QInputDialog, QLineEdit
from genome_utils import genomeException, parsePopulations, MAX_INFO_STRINGS
import sort,cleanVCF,calcStats,addBEDtoVCF,addCSVtoVCF,filterVCF,VCFtoCVF

PYTHON_WORDS = ["and","assert","break","class","continue",
                "def","del","elif","else","except",
                "exec","finally","for","from","global",
                "if","import","in","is","lambda",
                "not","or","pass","print","raise",
                "return","try","while",
                "Data","Float","Int","Numeric","Oxphys",
                "array","close","float","int","input",
                "open","range","type","write","zeros",
                "acos","asin","atan","cos","e",
                "exp","fabs","floor","log","log10",
                "pi","sin","sqrt","tan"]
SPECIAL_WORDS = ["keep_variant"]
RESERVED_TAGS = ["CHROM","POS","ID","REF","ALT","QUAL","FILTER"]
PRESET_FILTERS = {'FILTER == PASS': 'keep_variant = FILTER == "PASS"',
                  'QUAL >= 30': 'keep_variant = QUAL >= 30'}

TICKS_PER_PROCESS = 100
TICKS_FOR_LONG_PROCESSES = 1000

MAX_FILTER_STRING = 50

LOG_HEADER = "#!/bin/bash\n" + \
             "set -e\n\n" + \
             "#Log file generated by VCF Cleaner. There are two sections: shell commands, and population lists. If waiting for the scripts to run\n" + \
             "#in the GUI is annoying (e.g. you'd prefer to run stuff in a shell on a server somewhere), you can run this log file instead - just\n" + \
             "#make sure to chmod a+x, and edit the APP_DIR and TMP_DIR paths appropriately (APP_DIR should point to the folder containing all\n" + \
             "#the scripts, and TMP_DIR should point to an empty directory to store temporary files).\n" + \
             "#This file also serves as a population file that can be used as a parameter to calcStats.py. If you tweak this file, just be sure\n" + \
             "#that you don't start any comments with #tab, as that indicates population data - see the VCF Cleaner help page\n" + \
             "#(http://sci.utah.edu/~abigelow/vcfCleanerHelp.php#Populations) for details.\n\n"

# TODO: I will probably need to tweak this depending on the platform
APP_DIR = sys.path[0]

TMP_DIR = tempfile.gettempdir() + "/VCF_Cleaner"
temp = TMP_DIR
dupNumber = 2
while os.path.exists(TMP_DIR):
    TMP_DIR = temp + str(dupNumber)
    dupNumber += 1
os.makedirs(TMP_DIR)
with open(os.path.join(TMP_DIR,'README.txt'),'wb') as readme:
    readme.write("This is a temporary directory - if you\'re reading this there\'s a good chance VCF Cleaner was run on this machine and crashed somewhere in the middle. You may be able to " + \
                 "salvage some of the run from these contents. If you don't care, feel free to throw this away (nothing will break).")
    readme.close()

PURGE_TMP_DIR = True
ERROR_DETAILS = "This is the error Python gave me:\n\n%s\n\n" + \
                "If you'd like help, copy this message and post it at https://github.com/yasashiku/genepi_ngs_scripts/issues\n\n" + \
                "You may be able to salvage something by snooping in %s, but if you run again everything in there will be obliterated."

class sample(object):
    def __init__(self, name, sourcePop):
        self.name = name
        self.sourcePop = sourcePop
        self.globalName = '%s (%s)' % (name, sourcePop.globalName)
    
    def __hash__(self):
        return hash(self.globalName)
    
    def __eq__(self, other):
        return isinstance(other, sample) and self.name == other.name and self.sourcePop == other.sourcePop
    
    def __ne__(self, other):
        return not self.__eq__(other)

class population(object):
    def __init__(self, name, gui, source=False):
        self.name = name
        self.samples = set()
        self.source = source
        self.globalName = name
        
        self.gui = gui
    
    def addSample(self, s):
        if self.source:
            assert isinstance(s,str)
            s = sample(s,self)
        else:
            assert isinstance(s,sample)
        self.samples.add(s)
        return s
    
    def __repr__(self):
        return self.name
    
    def __eq__(self, other):
        return isinstance(other, population) and self.name == other.name and self.filePath == other.filePath
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    def addSamplesToPop(self):
        self.gui.addSamplesToPop(self)

class attribute(object):
    def __init__(self, name, sourcePath, additionalText=""):
        self.name = name
        self.sourcePath = sourcePath
        self.sourceFile = os.path.split(sourcePath)[1]
        self.additionalText = additionalText
        self.globalName = name
    
    def __repr__(self):
        outstr = "%s (%s" % (self.globalName,self.sourceFile)
        if self.additionalText == "":
            outstr += ")"
        else:
            outstr += ", %s)" % self.additionalText
        return outstr
    
    def __eq__(self, other):
        return isinstance(other,attribute) and self.name == other.name and self.sourcePath == other.sourcePath and self.additionalText == other.additionalText
    
    def __ne__(self, other):
        return not self.__eq__(other)

class statistic(object):
    def __init__(self, targetPop, function, backPop, ascending, revertHack):
        self.targetPop = targetPop
        self.function = function
        self.backPop = backPop
        self.ascending = ascending
        self.revertHack = revertHack
        self.globalName = self.targetPop + "_" + self.function + "_" + ('ASC' if self.ascending else 'DEC') + '_' + self.backPop + ('_rHack' if self.revertHack else '')
        if backPop == "ALT":
            self.description = "%s calculated by vcfCleaner, with allele-specific values listed in the same order as the ALT alleles"
        else:
            self.description = "%s calculated by vcfCleaner, with allele-specific values listed in order of %s allele frequency in the %s population. When %s is missing data, %s" % (self.function,
                                                                                                                                                                                      ('ascending' if self.ascending else 'descending'),
                                                                                                                                                                                      self.backPop,
                                                                                                                                                                                      self.backPop,
                                                                                                                                                                                      ('the original REF/ALT allele order is used (this technically makes "' + self.globalName + '" a misnomer' if self.revertHack else 'this will be "." even if ' + self.function + 'could have been calculated, because the allele order is undefined'))
    
    def __repr__(self):
        return self.globalName
    
    def __eq__(self, other):
        return isinstance(other,statistic) and self.targetPop == other.targetPop and self.function == other.function and self.backPop == other.backPop and self.ascending == other.ascending and self.revertHack == other.revertHack
    
    def __ne__(self, other):
        return not self.__eq__(other)

class filterExpression(object):
    def __init__(self, expression, columns):
        self.expression = expression
        self.columns = columns
    
    def __repr__(self):
        temp = "EXPRESSION: " + self.expression % tuple(self.columns)
        if len(temp) > MAX_FILTER_STRING:
            temp = temp[:MAX_FILTER_STRING-3] + "..."
        return temp
    
    def __eq__(self, other):
        return isinstance(other,filterExpression) and self.expression == other.expression and self.columns == other.columns
    
    def __ne__(self, other):
        return not self.__eq__(other)

class filterBed(object):
    def __init__(self, path):
        self.path = path
    
    def __repr__(self):
        temp = "BED: %s" % os.path.split(self.path)[1]
        if len(temp) > MAX_FILTER_STRING:
            temp = "..." + temp[len(temp)-MAX_FILTER_STRING+3:]
        return temp
    
    def __eq__(self, other):
        return isinstance(other,filterBed) and self.path == other.path
    
    def __ne__(self, other):
        return not self.__eq__(other)

class fieldBit(object):
    def __init__(self, field):
        self.field = field

class argObj:
    def __init__(self):
        pass

class gui:
    def __init__(self):
        self.loader = QUiLoader()
        infile = QFile("ui/Main.ui")
        infile.open(QFile.ReadOnly)
        self.window = self.loader.load(infile, None)
        infile.close()
        
        self.validOutputFormats = set(['.vcf','.cvf'])
        self.sourcePopBackground = QBrush(Qt.lightGray)
        
        # data structures
        self.popButtonBag = set()   # I get some strange seg fault errors due to some pyside garbage collection bug... I need to keep a pointer to
                                    # buttons I create dynamically to avoid this
        
        self.samples = {}
        self.populations = {}
        self.kgpPops = set()
        self.kgpFiles = {}
        for i in xrange(22):
            self.kgpFiles['chr%i' % (i+1)] = None
        self.kgpFiles['chrX'] = None
        self.vcfPop = None
        self.loadPopulations(sys.path[0] + "/KGP_populations.txt", source=True, kgp=True)
                
        self.variantFilters = []
        
        self.infoFields = {}
        
        self.includedAttributes = [] # contains actual attribute objects
        self.removedAttributes = [] # contains actual attribute objects
        
        self.csvAttributes = [] # really just contains strings
        self.bedAttributes = [] # really just contains strings
        self.calculatedAttributes = [] # really just contains strings
        
        # set up GUI - Data Sources Tab
        self.defaultPalette = self.window.vcfPathField.palette()
        self.errorPalette = self.window.vcfPathField.palette()
        self.errorPalette.setColor(QPalette.Base, QColor.fromRgb(255,150,150))
        
        self.window.browseVcfButton.clicked.connect(self.browseVcf)
        self.window.vcfPathField.editingFinished.connect(self.globalEnable)
        self.window.browseKgpButton.clicked.connect(self.browseKGP)
        self.window.kgpPathField.editingFinished.connect(self.updatePopAndGlobalEnable)
        self.window.browseOutputButton.clicked.connect(self.browseOutput)
        self.window.outputPathField.editingFinished.connect(self.globalEnable)
        self.window.browseLogButton.clicked.connect(self.browseLog)
        self.window.logPathField.editingFinished.connect(self.globalEnable)
        self.window.browseErrorButton.clicked.connect(self.browseError)
        self.window.errorPathField.editingFinished.connect(self.globalEnable)
        self.window.browseNonBiallelicButton.clicked.connect(self.browseNonBiallelic)
        self.window.nonBiallelicField.editingFinished.connect(self.globalEnable)
        
        self.window.treeWidget.itemSelectionChanged.connect(self.renameEnable)
        self.window.renameButton.clicked.connect(self.renamePop)
        self.window.createPopulationButton.clicked.connect(self.createPopulation)
        self.window.removePopOrSampleButton.clicked.connect(self.removePopOrSample)
        
        # Because the "Add Sample(s) to Population" and "Remove" buttons are created dynamically, we bind
        # the methods later, but I need to remember to bind to self.addSampleToPop and call self.removePopOrSample
        # appropriately
        
        # set up GUI - Attribute Settings Tab
        self.window.includeAttributeList.itemSelectionChanged.connect(self.changeIncludeAttribute)
        self.window.removeAttributeButton.clicked.connect(self.removeAttributes)
        
        self.window.cvfWarningLabel.hide()
        self.window.removeInfoList.itemSelectionChanged.connect(self.changeRemoveInfo)
        self.window.addInfoButton.clicked.connect(self.addInfo)
        
        self.window.functionComboBox.addItems(calcStats.allStats.STAT_NAMES)
        self.window.functionComboBox.currentIndexChanged.connect(self.calculateEnable)
        self.window.targetPopComboBox.currentIndexChanged.connect(self.calculateEnable)
        self.window.alleleReorderRadioButton.clicked.connect(self.calculateEnable)
        self.window.alleleVcfOrderRadioButton.clicked.connect(self.calculateEnable)
        self.window.backPopComboBox.currentIndexChanged.connect(self.calculateEnable)
        self.window.revertToRefAltCheckBox.clicked.connect(self.calculateEnable)
        self.window.createAttributeButton.clicked.connect(self.createAttribute)
        
        self.window.browseCsvButton.clicked.connect(self.browseCsv)
        self.window.csvColumnList.itemSelectionChanged.connect(self.changeCsvColumn)
        self.window.addCsvColumnButton.clicked.connect(self.addCsvAttribute)
        
        self.window.browseBedButton.clicked.connect(self.browseBed)
        self.window.bedScoreList.itemSelectionChanged.connect(self.changeBedScore)
        self.window.addBedScoreButton.clicked.connect(self.addBedAttribute)
        
        # set up GUI - Variant Filters Tab
        self.window.filterList.itemSelectionChanged.connect(self.changeFilter)
        self.window.removeFilterButton.clicked.connect(self.removeFilter)
        self.window.browseBedFilterButton.clicked.connect(self.addBedFilter)
        self.window.allAttributeComboBox.currentIndexChanged.connect(self.insertAttribute)
        self.window.presetFiltersComboBox.addItems(sorted(PRESET_FILTERS.iterkeys()))
        self.window.presetFiltersComboBox.currentIndexChanged.connect(self.switchToPresetFilter)
        self.window.addExpressionFilterButton.clicked.connect(self.addExpressionFilter)
        
        self.window.helpButton.clicked.connect(self.openHelpPage)
        self.window.quitButton.clicked.connect(self.quit)
        self.window.runButton.clicked.connect(self.run)
        
        self.globalEnable()
        
        self.window.show()
    
    # ***** Helper methods *****
    
    def loadPopulations(self, path, source=False, kgp=False, vcf=False):
        if vcf:
            newPops = calcStats.parseVcfHeader(path)[2]
            popOrder = [newPops.iterkeys().next()]
        else:
            newPops,popOrder = parsePopulations(path)
        
        popsToAdd = []
        
        for k in popOrder:
            newPop = population(k,self,source)
            appendDigit = 2
            while self.populations.has_key(newPop.globalName):
                newPop.globalName = "%s_%i" % (k, appendDigit)
                appendDigit += 1
            if kgp:
                self.kgpPops.add(newPop.globalName)
            elif vcf:
                self.vcfPop = newPop.globalName
            for s in newPops[k]:
                if source:
                    s = newPop.addSample(s)
                    assert not self.samples.has_key(s.globalName)
                    self.samples[s.globalName] = s
                else:
                    if not self.samples.has_key("%s (%s)" % (s,k)):
                        m = QMessageBox()
                        m.setText("Couldn't load population file; unknown sample: %s (%s)" % (s,k))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                        return
                    else:
                        newPop.addSample(self.samples["%s (%s)" % (s,k)])
            popsToAdd.append(newPop)
        # Now that we loaded without an error, we can add the populations
        for p in popsToAdd:
            self.populations[p.globalName] = p
        
        self.updatePopLists()
    
    def updatePopAndGlobalEnable(self):
        self.updatePopLists()
        self.globalEnable()
    
    def updatePopLists(self):
        popOrder = sorted(self.populations.iterkeys())
        includeKGP = os.path.isdir(self.window.kgpPathField.text())
        for cBox in [self.window.targetPopComboBox,self.window.backPopComboBox]:
            cBox.clear()
            cBox.addItem("Select...")
            for p in popOrder:
                if not includeKGP and p in self.kgpPops:
                    continue
                cBox.addItem(p)
            cBox.setCurrentIndex(0)
        
        self.window.treeWidget.clear()
        self.popButtonBag = set()
        
        for p in reversed(popOrder):
            if not includeKGP and p in self.kgpPops:
                continue
            pop = self.populations[p]
            parent = QTreeWidgetItem([p,''])
            self.window.treeWidget.insertTopLevelItem(0,parent)
            if pop.source:
                parent.setFlags(parent.flags() & Qt.ItemIsEnabled)
                parent.setBackground(0,self.sourcePopBackground)
                parent.setBackground(1,self.sourcePopBackground)
                addSamplesToPopButton = QPushButton('Add Samples...')
                self.popButtonBag.add(addSamplesToPopButton)    # a hack to keep a pointer to the button around... otherwise we seg fault
                addSamplesToPopButton.setDisabled(True) # these are here just for decoration
                self.window.treeWidget.setItemWidget(parent,1,addSamplesToPopButton)
                for s in sorted(pop.samples):
                    child = QTreeWidgetItem(parent)
                    child.setText(0,s.name)
                    child.setFlags(child.flags() & Qt.ItemIsEnabled)
                    child.setBackground(0,self.sourcePopBackground)
                    child.setBackground(1,self.sourcePopBackground)
            else:
                #parent.setFlags(parent.flags() | Qt.ItemIsEditable)
                addSamplesToPopButton = QPushButton('Add Samples...')
                self.popButtonBag.add(addSamplesToPopButton)    # a hack to keep a pointer to the button around... otherwise we seg fault
                self.window.treeWidget.setItemWidget(parent,1,addSamplesToPopButton)
                addSamplesToPopButton.clicked.connect(pop.addSamplesToPop)
                for s in sorted(pop.samples):
                    child = QTreeWidgetItem(parent)
                    child.setText(0,s.globalName)
    
    def renameEnable(self):
        pops = self.window.treeWidget.selectedItems()
        if len(pops) == 1 and not isinstance(pops[0].parent(),QTreeWidgetItem):  # really i.parent() == None would make more sense but a PySide bug doesn't allow that comparison
            popName = pops[0].text(0)
            pop = self.populations[popName]
            if popName not in self.kgpPops and not pop.source:
                self.window.renameButton.setEnabled(True)
            else:
                self.window.renameButton.setEnabled(False)
        else:
            self.window.renameButton.setEnabled(False)
    
    def renamePop(self):
        target = self.window.treeWidget.selectedItems()[0]
        oldName = target.text(0)
        newName,ok = QInputDialog.getText(self.window,u'Rename Population',u'Rename to:',QLineEdit.Normal,oldName)
        if ok and len(newName) > 0:
            if self.populations.has_key(newName):
                m = QMessageBox()
                m.setText("%s already exists." % newName)
                m.setIcon(QMessageBox.Critical)
                m.exec_()
                return
            self.populations[newName] = self.populations[oldName]
            del self.populations[oldName]
            self.populations[newName].name = newName
            self.populations[newName].globalName = newName
            self.updatePopLists()
    
    def globalEnable(self):
        allPathsValid = True
        
        inputString = self.window.vcfPathField.text()
        if os.path.exists(inputString):
            self.window.tabWidget.widget(1).setEnabled(True)
            self.window.tabWidget.widget(2).setEnabled(True)
            self.window.vcfPathField.setPalette(self.defaultPalette)
        else:
            allPathsValid = False
            self.window.tabWidget.widget(1).setEnabled(False)
            self.window.tabWidget.widget(2).setEnabled(False)
            self.window.runButton.setEnabled(False)
            
            if inputString != "":
                self.window.vcfPathField.setPalette(self.errorPalette)
            else:
                self.window.vcfPathField.setPalette(self.defaultPalette)
            
        outputString = self.window.outputPathField.text()
        outputExt = os.path.splitext(outputString)[1].lower()
        hasOutput = False
        self.window.outputPathField.setPalette(self.defaultPalette)
        if outputString != "":
            if not os.path.exists(os.path.dirname(outputString)) or outputExt not in self.validOutputFormats:
                allPathsValid = False
                self.window.outputPathField.setPalette(self.errorPalette)
            else:
                hasOutput = True
                if outputExt == '.cvf':
                    self.window.removeAttrLabel.setText("Flag these columns as IGNORE:")
                    self.window.cvfWarningLabel.show()
                else:
                    self.window.removeAttrLabel.setText("Remove these INFO attributes:")
                    self.window.cvfWarningLabel.hide()
        
        logString = self.window.logPathField.text()
        hasLog = False
        self.window.logPathField.setPalette(self.defaultPalette)
        if logString != "":
            if not os.path.exists(os.path.dirname(logString)):
                allPathsValid = False
                self.window.logPathField.setPalette(self.errorPalette)
            else:
                hasLog = True
        
        if hasOutput:
            if hasLog:
                self.window.runButton.setText("Save Log and Run")
            else:
                self.window.runButton.setText("Run")
        else:
            if hasLog:
                self.window.runButton.setText("Save Log")
            else:
                self.window.runButton.setText("Run")
        
        kgpString = self.window.kgpPathField.text()
        self.window.kgpPathField.setPalette(self.defaultPalette)
        if kgpString != "":
            if not os.path.exists(kgpString):
                allPathsValid = False
                self.window.kgpPathField.setPalette(self.errorPalette)
        
        errorString = self.window.errorPathField.text()
        self.window.errorPathField.setPalette(self.defaultPalette)
        if hasOutput:
            self.window.saveErrorWidget.setEnabled(True)
            if errorString != "":
                if not os.path.exists(os.path.dirname(errorString)) or os.path.splitext(errorString)[1].lower() != outputExt:
                    allPathsValid = False
                    self.window.errorPathField.setPalette(self.errorPalette)
        else:
            self.window.saveErrorWidget.setEnabled(False)
            self.window.errorPathField.setText("")
        
        nonBiallelicString = self.window.nonBiallelicField.text()
        self.window.nonBiallelicField.setPalette(self.defaultPalette)
        if hasOutput:
            self.window.saveNonBiallelicWidget.setEnabled(True)
            if nonBiallelicString != "":
                if not os.path.exists(os.path.dirname(nonBiallelicString)) or os.path.splitext(nonBiallelicString)[1].lower() != outputExt:
                    allPathsValid = False
                    self.window.nonBiallelicField.setPalette(self.errorPalette)
        else:
            self.window.saveNonBiallelicWidget.setEnabled(False)
            self.window.nonBiallelicField.setText("")
        
        self.window.runButton.setEnabled(allPathsValid and (hasLog or hasOutput))
        return allPathsValid,hasLog,hasOutput
    
    def updateAttrLists(self):
        self.window.filterList.clear()
        self.window.includeAttributeList.clear()
        self.changeIncludeAttribute()
        self.window.removeInfoList.clear()
        self.changeRemoveInfo()
        self.window.csvColumnList.clear()
        self.changeCsvColumn()
        self.window.bedScoreList.clear()
        self.changeBedScore()
        self.window.allAttributeComboBox.clear()
        
        # TODO: color the > n VALUES! elements red
        self.window.filterList.addItems([str(i) for i in self.variantFilters])
        self.window.includeAttributeList.addItems([str(i) for i in self.includedAttributes])
        self.window.removeInfoList.addItems([str(i) for i in self.removedAttributes])
        self.window.csvColumnList.addItems(self.csvAttributes)
        self.window.bedScoreList.addItems(self.bedAttributes)
        
        self.window.allAttributeComboBox.addItem("Paste...")
        self.window.allAttributeComboBox.addItems(SPECIAL_WORDS)
        self.window.allAttributeComboBox.insertSeparator(self.window.allAttributeComboBox.count()+1)
        self.window.allAttributeComboBox.addItems(RESERVED_TAGS)
        self.window.allAttributeComboBox.insertSeparator(self.window.allAttributeComboBox.count()+1)
        self.window.allAttributeComboBox.addItems([a.globalName for a in self.includedAttributes])
        self.window.allAttributeComboBox.addItems([a.globalName for a in self.removedAttributes])
    
    def includeAttribute(self, attr):
        if attr in self.removedAttributes:
            self.removedAttributes.remove(attr)
        if not attr in self.includedAttributes:
            self.includedAttributes.append(attr)
        self.uniquifyAttributes()
    
    def excludeAttribute(self, attr):
        if attr in self.includedAttributes:
            self.includedAttributes.remove(attr)
        if not attr in self.removedAttributes and attr.name in self.infoFields.iterkeys():  # only list excluded attributes that are already in the .vcf file
            self.removedAttributes.append(attr)
        self.uniquifyAttributes()
    
    def uniquifyAttributes(self):
        takenTags = set(RESERVED_TAGS)
        takenTags.update(PYTHON_WORDS)
        takenTags.update(SPECIAL_WORDS)
        for attr in self.includedAttributes:
            if isinstance(attr,attribute):
                name = attr.name
            else:
                name = attr.targetPop + "_" + attr.function + "_" + ('ASC' if attr.ascending else 'DEC') + '_' + attr.backPop + ('_rHack' if attr.revertHack else '')
            temp = name
            appendDigit = 2
            while temp in takenTags:
                temp = "%s_#%i" % (name,appendDigit)
                appendDigit += 1
            attr.globalName = temp
            takenTags.add(temp)
        
        takenTags = set(RESERVED_TAGS)
        for attr in self.removedAttributes:
            if isinstance(attr,attribute):
                name = attr.name
            else:
                name = attr.population + "_" + attr.function
            temp = name
            appendDigit = 2
            while temp in takenTags:
                temp = "%s_#%i" % (name,appendDigit)
                appendDigit += 1
            attr.globalName = temp
            takenTags.add(temp)
    
    def addSamplesToPop(self, pop):
        loader = QUiLoader()
        infile = QFile("ui/AddSamples.ui")
        infile.open(QFile.ReadOnly)
        window = loader.load(infile, None)
        infile.close()
        
        includeKGP = os.path.isdir(self.window.kgpPathField.text())
        
        for s in sorted(self.samples.itervalues()):
            if not includeKGP:
                keep = True
                for p in self.kgpPops:
                    if s in self.populations[p].samples:
                        keep = False
                        break
                if not keep:
                    continue
            window.listWidget.addItem(s.globalName)
        
        def localAddAll():
            for i in window.listWidget.selectedItems():
                pop.addSample(self.samples[i.text()])
            self.updatePopLists()
        
        def updateCount():
            numSamples = len(window.listWidget.selectedItems())
            window.label.setText("%i Samples Selected" % numSamples)
        
        window.listWidget.itemSelectionChanged.connect(updateCount)
        window.accepted.connect(localAddAll)
        
        window.show()
    
    def updateFilterList(self):
        self.window.filterList.clear()
        for f in self.variantFilters:
            self.window.filterList.addItem(str(f))
    
    # ***** GUI Bindings *****
    def browseVcf(self):
        fileName = QFileDialog.getOpenFileName(caption=u"Open .vcf file", filter=u"Variant Call Files (*.vcf)")[0]
        if fileName == '':
            return
        
        # count number of categorical values - this probably needs a progress bar
        progress = QProgressDialog(u"Scanning %s" % os.path.split(fileName)[1], u"Cancel", 0, 1000, parent=None)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        
        def tick():
            if progress.wasCanceled():
                return False
            newValue = min(progress.maximum(),progress.value()+1)
            progress.setValue(newValue)
            return True
        
        self.infoFields = cleanVCF.extractInfoFields(fileName,tickFunction=tick)
        
        progress.close()
        
        if self.vcfPop != None:
            for s in self.populations[self.vcfPop].samples:
                for p,pop in self.populations.iteritems():
                    if p == self.vcfPop:
                        continue
                    pop.samples.discard(s)
            del self.populations[self.vcfPop]
            self.vcfPop = None
        
        if self.infoFields == None:
            self.window.vcfPathField.setText("")
            self.updatePopLists()
            
            self.infoFields = {}
            self.includedAttributes = [] # contains actual attribute objects
            self.removedAttributes = [] # contains actual attribute objects
            
            self.calculatedAttributes = []
            self.updateAttrLists()
        else:
            self.window.vcfPathField.setText(fileName)
            self.loadPopulations(fileName, source=True, kgp=False, vcf=True)
                        
            self.includedAttributes = [] # contains actual attribute objects
            self.removedAttributes = [] # contains actual attribute objects
            
            for f in self.infoFields.itervalues():
                if f.maxedOut:
                    self.excludeAttribute(attribute(f.id, fileName, ">%i VALUES!" % MAX_INFO_STRINGS))
                else:
                    self.includeAttribute(attribute(f.id, fileName))
            
            self.calculatedAttributes = []
            self.updateAttrLists()
            
        self.globalEnable()
    
    def browseKGP(self):
        newDir = QFileDialog.getExistingDirectory(caption=u"Select the folder containing KGP .vcf files",options=QFileDialog.ShowDirsOnly)
        if newDir == '':
            return
        
        self.kgpFiles = {}
        for i in xrange(22):
            self.kgpFiles['chr%i' % (i+1)] = None
        self.kgpFiles['chrX'] = None
        
        for f in os.listdir(newDir):
            if 'genotypes.vcf' in f:
                c = f[f.find('chr'):]
                c = c[:c.find('.')]
                self.kgpFiles[c] = os.path.join(newDir,f)
        for c,f in self.kgpFiles.iteritems():
            if f == None:
                newDir = ''
                self.kgpFiles = {}
                for i in xrange(22):
                    self.kgpFiles['chr%i' % (i+1)] = None
                self.kgpFiles['chrX'] = None
                m = QMessageBox()
                m.setText("Couldn't find the *%s*.genotypes.vcf* file" % c)
                m.setIcon(QMessageBox.Critical)
                m.exec_()
                break
        self.window.kgpPathField.setText(newDir)
        self.updatePopLists()
    
    def browseOutput(self):
        fileName = QFileDialog.getSaveFileName(caption=u"Save file", filter=u"Variant Call File (*.vcf);;CompreheNGSive Variant File (*.cvf)")[0]
        if fileName == '':
            return
                
        if fileName == self.window.errorPathField.text() or fileName == self.window.nonBiallelicField.text() or fileName == self.window.vcfPathField.text():
            m = QMessageBox()
            m.setText("You are already using that file name; please choose another.")
            m.setIcon(QMessageBox.Critical)
            m.exec_()
            return
        
        self.window.outputPathField.setText(fileName)
        self.window.saveErrorWidget.setEnabled(True)
        self.window.saveNonBiallelicWidget.setEnabled(True)
        self.globalEnable()
    def browseLog(self):
        fileName = QFileDialog.getSaveFileName(caption=u"Save Log file", filter=u"Log File (*.log);;Text File (*.txt)")[0]
        if fileName == '':
            return
        self.window.logPathField.setText(fileName)
    def browseError(self):
        e = self.window.outputPathField.text().lower()
        if e.endswith('.vcf'):
            f = u"Variant Call File (*.vcf)"
        elif e.endswith('.cvf'):
            f = u"CompreheNGSive Variant File (*.cvf)"
        
        fileName = QFileDialog.getSaveFileName(caption=u"Save file", filter=f)[0]
        if fileName == '':
            return
                
        if fileName == self.window.outputPathField.text() or fileName == self.window.nonBiallelicField.text() or fileName == self.window.vcfPathField.text():
            m = QMessageBox()
            m.setText("You are already using that file name; please choose another.")
            m.setIcon(QMessageBox.Critical)
            m.exec_()
            return
        
        self.window.errorPathField.setText(fileName)
        self.globalEnable()
    def browseNonBiallelic(self):
        e = self.window.outputPathField.text().lower()
        if e.endswith('.vcf'):
            f = u"Variant Call File (*.vcf)"
        elif e.endswith('.cvf'):
            f = u"CompreheNGSive Variant File (*.cvf)"
        
        fileName = QFileDialog.getSaveFileName(caption=u"Save file", filter=f)[0]
        if fileName == '':
            return
                
        if fileName == self.window.outputPathField.text() or fileName == self.window.errorPathField.text() or fileName == self.window.vcfPathField.text():
            m = QMessageBox()
            m.setText("You are already using that file name; please choose another.")
            m.setIcon(QMessageBox.Critical)
            m.exec_()
            return
        
        self.window.nonBiallelicField.setText(fileName)
        self.globalEnable()
    def createPopulation(self):
        newPop = population("Population",self,source=False)
        appendDigit = 2
        while self.populations.has_key(newPop.globalName):
            newPop.globalName = "%s_%i" % ("Population", appendDigit)
            appendDigit += 1
        self.populations[newPop.globalName] = newPop
        self.updatePopLists()
    def removePopOrSample(self):
        for i in self.window.treeWidget.selectedItems():
            if not isinstance(i.parent(),QTreeWidgetItem):  # really i.parent() == None would make more sense but a PySide bug doesn't allow that comparison
                # delete a whole population
                if not self.populations[i.text(0)].source:
                    del self.populations[i.text(0)]
            else:
                # delete a sample from a population
                # TODO: got a strange bug when removing an individual... eventually delete this test here
                if not self.populations.has_key(i.parent().text(0)):
                    print i.parent().text(0)
                    print self.populations.keys()
                    sys.exit(1)
                if not self.populations[i.parent().text(0)].source:
                    self.populations[i.parent().text(0)].samples.discard(self.samples[i.text(0)])
        self.updatePopLists()
    
    def changeIncludeAttribute(self):
        if len(self.window.includeAttributeList.selectedItems()) > 0:
            self.window.removeAttributeButton.setEnabled(True)
        else:
            self.window.removeAttributeButton.setEnabled(False)
    
    def removeAttributes(self):
        attrs = []
        for a in self.window.includeAttributeList.selectedItems():
            attrs.append(self.includedAttributes[self.window.includeAttributeList.indexFromItem(a).row()])
        
        for a in attrs:
            self.includedAttributes.remove(a)
            if isinstance(a,attribute) and self.window.vcfPathField.text() == a.sourcePath:
                self.removedAttributes.append(a)
            elif isinstance(a,statistic):
                self.calculatedAttributes.remove(a.globalName)
        self.uniquifyAttributes()
        self.updateAttrLists()
        self.calculateEnable()
    
    def changeRemoveInfo(self):
        if len(self.window.removeInfoList.selectedItems()) > 0:
            self.window.addInfoButton.setEnabled(True)
        else:
            self.window.addInfoButton.setEnabled(False)
    
    def addInfo(self):
        attrs = []
        for a in self.window.removeInfoList.selectedItems():
            attrs.append(self.removedAttributes[self.window.removeInfoList.indexFromItem(a).row()])
        
        for a in attrs:
            self.removedAttributes.remove(a)
            self.includedAttributes.append(a)
        self.uniquifyAttributes()
        self.updateAttrLists()
    
    def calculateEnable(self):
        statSelected = self.window.functionComboBox.currentIndex() != 0 and self.window.targetPopComboBox.currentIndex() != 0
        if self.window.alleleReorderRadioButton.isChecked():
            self.window.ascendingRadioButton.setEnabled(True)
            self.window.descendingRadioButton.setEnabled(True)
            self.window.backPopComboBox.setEnabled(True)
            self.window.revertToRefAltCheckBox.setEnabled(True)
            if self.window.backPopComboBox.currentIndex() != 0:
                tempStat = statistic(self.window.targetPopComboBox.currentText(),
                                     self.window.functionComboBox.currentText(),
                                     self.window.backPopComboBox.currentText(),
                                     self.window.ascendingRadioButton.isChecked(),
                                     self.window.revertToRefAltCheckBox.isChecked())
            else:
                tempStat = None
        else:
            self.window.ascendingRadioButton.setEnabled(False)
            self.window.descendingRadioButton.setEnabled(False)
            self.window.backPopComboBox.setEnabled(False)
            self.window.revertToRefAltCheckBox.setEnabled(False)
            tempStat = statistic(self.window.targetPopComboBox.currentText(),
                                 self.window.functionComboBox.currentText(),
                                 "ALT",
                                 False,
                                 False)
        if statSelected and tempStat != None and tempStat.globalName not in self.calculatedAttributes:
            self.window.createAttributeButton.setEnabled(True)
        else:
            self.window.createAttributeButton.setEnabled(False)
        
    def createAttribute(self):
        if self.window.alleleReorderRadioButton.isChecked():
            newStat = statistic(self.window.targetPopComboBox.currentText(),
                                 self.window.functionComboBox.currentText(),
                                 self.window.backPopComboBox.currentText(),
                                 self.window.ascendingRadioButton.isChecked(),
                                 self.window.revertToRefAltCheckBox.isChecked())
        else:
            newStat = statistic(self.window.targetPopComboBox.currentText(),
                                 self.window.functionComboBox.currentText(),
                                 "ALT",
                                 False,
                                 False)
        assert newStat.globalName not in self.calculatedAttributes
        self.calculatedAttributes.append(newStat.globalName)
        self.includeAttribute(newStat)
        self.updateAttrLists()
        self.calculateEnable()
    
    def browseCsv(self):
        fileName = QFileDialog.getOpenFileName(caption=u"Open .csv file", filter=u"Tabular file (*.csv)")[0]
        if fileName != '':
            self.window.csvPathField.setText(fileName)
            self.csvAttributes = []
            try:
                headers,chromColumn,posColumn,idColumn = addCSVtoVCF.sniffCsv(fileName)[1:]
                for i,a in enumerate(headers):
                    if i != chromColumn and i != posColumn and i != idColumn:
                        self.csvAttributes.append(a)
            except genomeException:
                self.window.csvPathField.setText("")
                self.csvAttributes = []
                m = QMessageBox()
                m.setText("The .csv file was formatted incorrectly; make sure it has a \"CHROM\", \"POS\", and optionally an \"ID\" header.")
                m.setIcon(QMessageBox.Warning)
                m.exec_()
            self.updateAttrLists()
    
    def changeCsvColumn(self):
        if len(self.window.csvColumnList.selectedItems()) > 0:
            self.window.addCsvColumnButton.setEnabled(True)
        else:
            self.window.addCsvColumnButton.setEnabled(False)
    
    def addCsvAttribute(self):
        if self.window.exactRadioButton.isChecked():
            mode = "Exact"
        elif self.window.copyRadioButton.isChecked():
            mode = "Copy"
        else:
            mode = "Interpolate"
        for a in self.window.csvColumnList.selectedItems():
            attr = attribute(a.text(),self.window.csvPathField.text(),mode)
            if attr not in self.includedAttributes:
                self.includedAttributes.append(attr)
        self.uniquifyAttributes()
        self.updateAttrLists()
    
    def browseBed(self):
        fileName = QFileDialog.getOpenFileName(caption=u"Open .bed file", filter=u"BED file (*.bed)")[0]
        if fileName != '':
            self.window.bedPathField.setText(fileName)
            self.bedAttributes = []
            try:
                scoreNames,bedRegions = addBEDtoVCF.sniffBed(fileName)
                for a in scoreNames:
                    self.bedAttributes.append(a)
            except genomeException:
                self.window.bedPathField.setText("")
                self.bedAttributes = []
                m = QMessageBox()
                m.setText("The .bed file must have names and scores for every feature in order to attach scores to variants.")
                m.setIcon(QMessageBox.Warning)
                m.exec_()
            self.updateAttrLists()
    
    def changeBedScore(self):
        if len(self.window.bedScoreList.selectedItems()) > 0:
            self.window.addBedScoreButton.setEnabled(True)
        else:
            self.window.addBedScoreButton.setEnabled(False)
    
    def addBedAttribute(self):
        for a in self.window.bedScoreList.selectedItems():
            attr = attribute(a.text(),self.window.bedPathField.text())
            if not attr in self.includedAttributes:
                self.includedAttributes.append(attr)
        self.uniquifyAttributes()
        self.updateAttrLists()
    
    # set up GUI - Variant Filters Tab
    def changeFilter(self):
        r = self.window.filterList.currentRow()
        if r > len(self.variantFilters):
            self.window.expressionField.setPlainText("")
            return
        f = self.variantFilters[r]
        if isinstance(f,filterBed):
            self.window.expressionField.setPlainText(f.expression % tuple(f.columns))
        else:
            self.window.expressionField.setPlainText("")
    def removeFilter(self):
        if self.window.filterList.count() == 0:
            return
        del self.variantFilters[self.window.filterList.currentRow()]
        self.updateFilterList()
    def addBedFilter(self):
        fileName = QFileDialog.getOpenFileName(caption=u"Open .bed file", filter=u"BED file (*.bed)")[0]
        if fileName != '':
            newFilter = filterBed(fileName)
            if newFilter not in self.variantFilters:
                self.variantFilters.append(newFilter)
            self.updateFilterList()
    def insertAttribute(self):
        if self.window.allAttributeComboBox.currentIndex() != 0:
            self.window.expressionField.insertPlainText(self.window.allAttributeComboBox.currentText())
            self.window.allAttributeComboBox.setCurrentIndex(0)
    def switchToPresetFilter(self):
        if self.window.presetFiltersComboBox.currentIndex() != 0:
            self.window.expressionField.setPlainText(PRESET_FILTERS[self.window.presetFiltersComboBox.currentText()])
            self.window.presetFiltersComboBox.setCurrentIndex(0)
    def addExpressionFilter(self):
        expr = [self.window.expressionField.toPlainText()]
        
        allTags = [""]
        allTags.extend(RESERVED_TAGS)
        allTags.extend([a.globalName for a in self.includedAttributes])
        allTags.extend([a.globalName for a in self.removedAttributes])
        
        # extract out the variables by splitting up the expression
        for a in allTags[1:]:
            newExpr = []
            f = fieldBit(a)
            for e in expr:
                if isinstance(e,fieldBit):
                    newExpr.append(e)
                else:
                    codeBits = e.split(a)
                    firstBit = True
                    for c in codeBits:
                        if firstBit:
                            firstBit = False
                        else:
                            newExpr.append(f)
                        newExpr.append(c)
            expr = newExpr
        
        # now assemble the expression string and the columns that will be fed in
        exprStr = ""
        columns = []
        for e in expr:
            if isinstance(e,fieldBit):
                exprStr += "%s"
                columns.append(e.field)
            else:
                exprStr += e
                
        result = filterExpression(exprStr,columns)
        if result not in self.variantFilters:
            self.variantFilters.append(result)
            self.updateFilterList()
    
    def openHelpPage(self):
        webbrowser.open('http://sci.utah.edu/~abigelow/vcfCleanerHelp.php',new=2)
    
    def quit(self):
        self.window.reject()
    
    def run(self):
        global PURGE_TMP_DIR
        validPaths,hasLog,hasOutput = self.globalEnable()
        if not validPaths:
            return
        
        # If there isn't a valid log path, we'll still dump one to a temp directory
        logPath = self.window.logPathField.text()
        outPath = self.window.outputPathField.text()
        vcfPath,sourceFiles,statsToCalculate,bedAttribFiles,csvAttribFiles,isCvf,newPopFields = self.generateLogFile(logPath)
        
        # Run if we need to
        if hasOutput:
            numTicks = TICKS_PER_PROCESS * len(sourceFiles)
            numTicks += TICKS_PER_PROCESS
            numTicks += TICKS_FOR_LONG_PROCESSES
            numTicks += TICKS_PER_PROCESS*len(bedAttribFiles)
            numTicks += TICKS_PER_PROCESS*len(csvAttribFiles)
            numTicks += TICKS_PER_PROCESS*len(self.variantFilters)
            numTicks += TICKS_PER_PROCESS
            
            # Okay, we've sorted out how many ticks we need, now show the dialog
            # count number of categorical values - this probably needs a progress bar
            progress = QProgressDialog(u"Running...", u"Cancel", 0, numTicks, parent=None)
            progress.setWindowModality(Qt.WindowModal)
            progress.show()
            
            def tick():
                if progress.wasCanceled():
                    raise Exception('Cancel clicked.')
                newValue = min(progress.maximum(),progress.value()+1)
                progress.setValue(newValue)
                return True
            
            # Sort first
            tempTicks = 0
            for f in sourceFiles:
                progress.setLabelText("Sorting %s..." % f)
                progress.setValue(tempTicks)
                
                baseName = os.path.split(f)[1]
                args = argObj()
                args.infile = f
                args.outfile = os.path.join(TMP_DIR,baseName)
                try:
                    sort.run(args,tick,TICKS_PER_PROCESS)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                
                tempTicks += TICKS_PER_PROCESS
            
            # Throw out fields we explicitly decided we want to remove
            if not isCvf and len(self.removedAttributes) > 0:
                progress.setLabelText("Cleaning fields...")
                progress.setValue(TICKS_PER_PROCESS * len(sourceFiles))
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = os.path.join(TMP_DIR,"temp_"+vcfPath)
                args.max_strings = 0
                args.remove_info = " ".join(a.name for a in self.removedAttributes)
                try:
                    cleanVCF.run(args)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                os.rename(os.path.join(TMP_DIR,"temp_" + vcfPath),os.path.join(TMP_DIR,vcfPath))
            
            # Calculate statistics
            if len(statsToCalculate) > 1:
                progress.setLabelText("Calculating Statistics...")
                progress.setValue(TICKS_PER_PROCESS * len(sourceFiles) + TICKS_PER_PROCESS)
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = os.path.join(TMP_DIR,"temp_"+vcfPath)
                if not os.path.exists(logPath):
                    logPath = os.path.join(TMP_DIR,"tmpLogFile.sh")
                dataPath = self.window.kgpPathField.text()
                if dataPath != "":
                    args.data = dataPath
                else:
                    args.data = None
                args.popFile = logPath
                args.calculate_AF = []
                args.calculate_Carriage = []
                args.calculate_Samples_w_calls = []
                for a in self.includedAttributes:
                    if isinstance(a,statistic):
                        calculation = [a.targetPop]
                        if a.backPop != "ALT":
                            calculation.append(a.backPop)
                            if a.ascending == True:
                                calculation.append("ASC")
                            else:
                                calculation.append("DEC")
                            if a.revertHack == True:
                                calculation.append("True")
                        if a.function == calcStats.allStats.STAT_NAMES[calcStats.allStats.AF]:
                            args.calculate_AF.append(calculation)
                        elif a.function == calcStats.allStats.STAT_NAMES[calcStats.allStats.Carriage]:
                            args.calculate_Carriage.append(calculation)
                        elif a.function == calcStats.allStats.STAT_NAMES[calcStats.allStats.Samples_w_calls]:
                            args.calculate_Samples_w_calls.append(calculation)
                        else:
                            raise Exception("Unknown Statistic: %s" % a.function)
                try:
                    calcStats.run(args,tick,TICKS_FOR_LONG_PROCESSES)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                os.rename(os.path.join(TMP_DIR,"temp_" + vcfPath),os.path.join(TMP_DIR,vcfPath))
            
            # Add any .bed stats
            tempTicks = TICKS_PER_PROCESS * len(sourceFiles) + TICKS_PER_PROCESS + TICKS_FOR_LONG_PROCESSES
            for f,attribs in bedAttribFiles.iteritems():
                progress.setLabelText("Applying .bed Attributes...")
                progress.setValue(tempTicks)
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = os.path.join(TMP_DIR,"temp_"+vcfPath)
                baseName = os.path.split(f)[1]
                args.bedfile = os.path.join(TMP_DIR,baseName)
                args.names = [a.name for a in attribs]
                
                try:
                    addBEDtoVCF.run(args)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                os.rename(os.path.join(TMP_DIR,"temp_" + vcfPath),os.path.join(TMP_DIR,vcfPath))
                
                tempTicks += TICKS_PER_PROCESS
            
            # Add any .csv stats
            tempTicks = TICKS_PER_PROCESS * len(sourceFiles) + TICKS_PER_PROCESS + TICKS_FOR_LONG_PROCESSES + TICKS_PER_PROCESS * len(bedAttribFiles)
            for f,attribs in csvAttribFiles.iteritems():
                progress.setLabelText("Applying .csv Attributes...")
                progress.setValue(tempTicks)
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = os.path.join(TMP_DIR,"temp_"+vcfPath)
                baseName = os.path.split(f)[1]
                args.csvFile = os.path.join(TMP_DIR,baseName)
                args.exact = []
                args.nearest = []
                args.interpolate = []
                
                for a in attribs:
                    if a.additionalText == 'Exact':
                        args.exact.append(a.name)
                    elif a.additionalText == 'Copy':
                        args.nearest.append(a.name)
                    elif a.additionalText == 'Interpolate':
                        args.interpolate.append(a.name)
                    else:
                        raise Exception('Unknown csv additionalText: %s' % str(a.additionalText))
                
                try:
                    addCSVtoVCF.run(args)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                os.rename(os.path.join(TMP_DIR,"temp_" + vcfPath),os.path.join(TMP_DIR,vcfPath))
                
                tempTicks += TICKS_PER_PROCESS
            
            # Now apply the filters
            tempTicks = TICKS_PER_PROCESS * len(sourceFiles) + TICKS_PER_PROCESS + TICKS_FOR_LONG_PROCESSES + TICKS_PER_PROCESS * len(bedAttribFiles) + TICKS_PER_PROCESS * len(csvAttribFiles)
            for f in self.variantFilters:
                progress.setLabelText("Applying filters...")
                progress.setValue(tempTicks)
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = os.path.join(TMP_DIR,"temp_"+vcfPath)
                if isinstance(f,filterBed):
                    args.bed = f.path
                else:
                    expressionNumber = 2
                    temp = "expression.py"
                    while os.path.exists(os.path.join(TMP_DIR,temp)):
                        temp = "expression%i.py" % expressionNumber
                        expressionNumber += 1
                    args.expression = temp
                    args.columns = f.columns
                
                try:
                    filterVCF.run(args)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
                os.rename(os.path.join(TMP_DIR,"temp_" + vcfPath),os.path.join(TMP_DIR,vcfPath))
                
                tempTicks += TICKS_PER_PROCESS
            
            # We're almost done... convert to .cvf or copy to the target destination
            tempTicks = TICKS_PER_PROCESS * len(sourceFiles) + TICKS_PER_PROCESS + TICKS_FOR_LONG_PROCESSES + TICKS_PER_PROCESS * len(bedAttribFiles) + TICKS_PER_PROCESS * len(csvAttribFiles) + TICKS_PER_PROCESS * len(self.variantFilters)

            if isCvf:
                progress.setLabelText("Converting to .cvf...")
                progress.setValue(tempTicks)
                
                args = argObj()
                args.infile = os.path.join(TMP_DIR,vcfPath)
                args.outfile = outPath
                args.max_strings = 0    # we've already gotten rid of problematic columns
                args.separate_info_fields = "True"
                args.count_separate = "False"
                args.ignore = [a.name for a in self.removedAttributes]
                args.ignore.extend(newPopFields)
                
                try:
                    VCFtoCVF.run(args)
                except Exception, e:
                    progress.close()
                    if e.message != 'Cancel clicked.':
                        m = QMessageBox()
                        m.setText("The run couldn't complete because of an error.")
                        PURGE_TMP_DIR = False
                        m.setDetailedText(ERROR_DETAILS % (traceback.format_exc(),TMP_DIR))
                        m.setIcon(QMessageBox.Critical)
                        m.exec_()
                    return
            else:
                os.rename(os.path.join(TMP_DIR,vcfPath),outPath)
            progress.close()
        self.window.accept()
    
    def generateLogFile(self, path):
        if not os.path.exists(os.path.dirname(path)):
            # just write a temporary file somewhere else and delete it after
            outfile = open(os.path.join(TMP_DIR,'tmpLogFile.sh'),'wb')
        else:
            outfile = open(path,'wb')
        outfile.write(LOG_HEADER)
        outfile.write('APP_DIR=%s\n' % APP_DIR)
        outfile.write('TMP_DIR=%s\n\n' % TMP_DIR)
        
        vcfPath = self.window.vcfPathField.text()
        outPath = self.window.outputPathField.text()
        if outPath == "":
            outPath = os.path.devnull
            outfile.write('#***WARNING***: You didn\'t specify an output path in VCF Cleaner; you should replace %s with the place you want the resulting file to go.\n' % os.devnull)
        isCvf = outPath.strip().lower().endswith('cvf')
        
        sourceFiles = set()
        statsToCalculate = ""
        newPopFields = set()
        bedAttribFiles = defaultdict(set)
        csvAttribFiles = defaultdict(set)
        for a in self.includedAttributes:
            if isinstance(a,attribute):
                sourceFiles.add(a.sourcePath)
                ext = os.path.splitext(a.sourcePath)[1].lower()
                if ext == '.bed':
                    bedAttribFiles[a.sourcePath].add(a)
                elif ext == '.csv':
                    csvAttribFiles[a.sourcePath].add(a)
            elif isinstance(a,statistic):
                statStr = "--calculate_%s %s" % (a.function,a.targetPop)
                if a.backPop != "ALT":
                    backPop = str(a.backPop)
                    statStr += " %s" % a.backPop
                    if a.ascending == True:
                        backPop += "_ASC"
                        statStr += " ASC"
                    else:
                        backPop += "_DEC"
                        statStr += " DEC"
                    backPop += "_AO"
                    if a.revertHack == True:
                        backPop += "_rHack"
                        statStr += " True"
                    newPopFields.add(backPop)
                statsToCalculate += " %s" % statStr
        sourceFiles.add(vcfPath)
        vcfPath = os.path.split(vcfPath)[1]
        
        # Sort first
        for f in sourceFiles:
            baseName = os.path.split(f)[1]
            outfile.write('echo "Sorting %s..."\n' % baseName)
            outfile.write('python $APP_DIR/sort.py --in %s --out $TMP_DIR/%s\n' % (f,baseName))
        # Throw out fields we explicitly decided we want to remove
        if not isCvf and len(self.removedAttributes) > 0:
            attsToRemove = " ".join(a.name for a in self.removedAttributes)
            outfile.write('echo "Cleaning..."\n')
            outfile.write('python $APP_DIR/cleanVCF.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --max_strings 0 --remove_info %s\n' % (vcfPath,vcfPath,attsToRemove))
            outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
        # Run calcStats.py
        if len(statsToCalculate) > 1:
            dataText = self.window.kgpPathField.text()
            if dataText != "":
                dataText = " --data " + dataText
            outfile.write('#***WARNING*** You should either copy KGP_populations.txt to the same directory as this script or change "$0" to the path containing KGP_populations.txt\n')
            outfile.write('echo "Running calcStats.py..."\n')
            outfile.write('python $APP_DIR/calcStats.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --populations `dirname $0`/KGP_populations.txt%s%s\n' % (vcfPath,vcfPath,dataText,statsToCalculate))
            outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
        # Add any .bed stats
        for f,attribs in bedAttribFiles.iteritems():
            baseName = os.path.split(f)[1]
            featureNames = " ".join(a.name for a in attribs)
            outfile.write('echo "Running addBEDtoVCF.py..."\n')
            outfile.write('python $APP_DIR/addBEDtoVCF.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --bed $TMP_DIR/%s --names %s\n' % (vcfPath,vcfPath,baseName,featureNames))
            outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
        # Add any .csv stats
        for f,attribs in csvAttribFiles.iteritems():
            baseName = os.path.split(f)[1]
            exactColumns = []
            nearestColumns = []
            interpolateColumns = []
            for a in attribs:
                if a.additionalText == 'Exact':
                    exactColumns.append(a.name)
                elif a.additionalText == 'Copy':
                    nearestColumns.append(a.name)
                elif a.additionalText == 'Interpolate':
                    interpolateColumns.append(a.name)
                else:
                    raise Exception('Unknown csv additionalText: %s' % str(a.additionalText))
            columnList = ""
            if len(exactColumns) > 0:
                columnList += "--exact " + " ".join(exactColumns)
            if len(nearestColumns) > 0:
                columnList += "--nearest " + " ".join(nearestColumns)
            if len(interpolateColumns) > 0:
                columnList += "--interpolate" + " ".join(interpolateColumns)
            outfile.write('echo "Running addCSVtoVCF.py..."\n')
            outfile.write('python $APP_DIR/addCSVtoVCF.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --csv $TMP_DIR/%s --omit_mismatches %s\n' % (vcfPath,vcfPath,baseName,columnList))
            outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
        # Now apply the filters
        for f in self.variantFilters:
            if isinstance(f,filterBed):
                outfile.write('echo "Running filterVCF.py..."\n')
                outfile.write('python $APP_DIR/filterVCF.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --bed %s\n' % (vcfPath,vcfPath,f.path))
                outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
            else:
                expressionNumber = 2
                temp = "expression.py"
                while os.path.exists(os.path.join(TMP_DIR,temp)):
                    temp = "expression%i.py" % expressionNumber
                    expressionNumber += 1
                outfile.write('echo "%s" > $TMP_DIR/%s\n' % (f.expression.replace('"','\\"'),temp))
                outfile.write('echo "Running filterVCF.py..."\n')
                outfile.write('python $APP_DIR/filterVCF.py --in $TMP_DIR/%s --out $TMP_DIR/temp_%s --expression $TMP_DIR/%s --columns %s\n' % (vcfPath,vcfPath,temp," ".join(f.columns)))
                outfile.write('mv $TMP_DIR/temp_%s $TMP_DIR/%s\n' % (vcfPath,vcfPath))
        # Convert to .cvf or just copy the .vcf
        if isCvf:
            attsToRemove = " ".join(a.name for a in self.removedAttributes)
            if len(newPopFields) > 0:
                if len(attsToRemove) > 0:
                    attsToRemove += " "
                attsToRemove += " ".join(newPopFields)
            outfile.write('python $APP_DIR/VCFtoCVF --in $TMP_DIR/%s --out %s --max_strings 0 --separate_info_fields --ignore %s' % (vcfPath,outPath,attsToRemove))
        else:
            outfile.write('mv $TMP_DIR/%s %s\n' % (vcfPath,outPath))
        
        # Whew, now that the shell script crap is done, write the population section
        outfile.write('\n\n\n')
        #TODO
        
        
        outfile.write('echo "Done"\n')
        
        if not os.path.exists(os.path.dirname(path)):
            os.remove(os.path.join(TMP_DIR,'tmpLogFile.sh'))    # make sure to delete the log file if we didn't really want to create it
        
        return vcfPath,sourceFiles,statsToCalculate,bedAttribFiles,csvAttribFiles,isCvf,newPopFields
        
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = gui()
    exitCode = app.exec_()
    if PURGE_TMP_DIR:
        shutil.rmtree(TMP_DIR)
    sys.exit(exitCode)